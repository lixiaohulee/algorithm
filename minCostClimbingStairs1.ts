function minCostClimbingStairs(cost: number[]): number {
    //分析 有n个台阶，可以从第一个台阶(0) 或者 从第二个台阶(1) 开始往上爬 直到爬到楼层顶部(第n+1个台阶) 最低花销

    //最值问题
    //确定状态 最后一步&子问题  第n个台阶 这个台阶你可以选择爬一个台阶 花销就是cost[n-1] 总花销就是签n-1台阶最小的花销加上这const[n-1]
    //子问题出现 dp[i] 就代表爬到第i台阶的最少花销
    //状态转移方程 dp[i] = dp[i-1] + const[i]
    //初始条件和边界情况 dp[0] = 0 
    //计算顺序 因为有状态依赖 所以从小到大计算 

    const n = cost.length;

    const dp = Array(n + 1);

    dp[0] = 0;  //爬到第一台阶 最少肯定是0 因为你可以从第一个台阶开始爬
    dp[1] = 0;  //爬到第二个台阶 最少肯定是0 因为你初始可以从第二个台阶开始爬

    for (let i = 2; i < n + 1; i++) {
        //第三个台阶一定是从第1个台阶或者第二个跳上来的 没问题吧 每次可以跳一个或者两个
        //那么跳到这个台阶的总花销一定是跳到第一个台阶或者第二个台阶的花销加上第一个或者第二个台阶跳时的花费值的最小值

        dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
    }

    return dp[n];
};
